<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module provides traits for calling rust functions dynamically."><title>puffin::algebra::dynamic_function - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-fecee23daa4e8a6d.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="puffin" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-nightly (4ac7bcbaa 2024-09-04)" data-channel="nightly" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../puffin/index.html">puffin</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">Module dynamic_<wbr>function</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In puffin::<wbr>algebra</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">puffin</a>::<wbr><a href="../index.html">algebra</a>::<wbr><a class="mod" href="#">dynamic_function</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/puffin/algebra/dynamic_function.rs.html#1-351">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module provides traits for calling rust functions dynamically.</p>
<p>All functions which implement the DynamicFunction trait can be called by passing an array of
<a href="../../protocol/trait.EvaluatedTerm.html" title="trait puffin::protocol::EvaluatedTerm"><code>EvaluatedTerm</code></a>s to it. The return value is again of type <a href="../../protocol/trait.EvaluatedTerm.html" title="trait puffin::protocol::EvaluatedTerm"><code>EvaluatedTerm</code></a>.</p>
<p>Rust is a statically typed language. That means the compiler would be able to statically verify
that a term evaluates without any type errors.</p>
<p>While this is generally an advance, in the case of our fuzzer this is not very helpful.
The fuzzer should be able to mutate the term trees arbitrarily. Of course, we also have
to check for the types during runtime. If types are not compatible then, the evaluation
of the term will fail. But this is not something that can be done during compile time.
Therefore, we introduced a trait for dynamically typed functions on top of statically
typed Rust functions.</p>
<p>Each function which implements the following trait can be made into a dynamic function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>puffin::algebra::error::FnError;

<span class="kw">type </span>ConcreteFunction&lt;A1, A2, A3, R&gt; = <span class="kw">dyn </span>Fn(A1, A2, A3) -&gt; <span class="prelude-ty">Result</span>&lt;R, FnError&gt;;</code></pre></div>
<p>where <code>A1</code>, <code>A2</code>, <code>A3</code> are argument types and <code>R</code> is the return type. From these statically
typed function we can generate dynamically types ones which implement the following trait:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::any::Any;

<span class="kw">use </span>puffin::algebra::error::FnError;
<span class="kw">use </span>puffin::protocol::{EvaluatedTerm, ProtocolTypes};

<span class="kw">pub trait </span>DynamicFunction&lt;PT: ProtocolTypes&gt;:
    Fn(<span class="kw-2">&amp;</span>Vec&lt;Box&lt;<span class="kw">dyn </span>EvaluatedTerm&lt;PT&gt;&gt;&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;Box&lt;<span class="kw">dyn </span>EvaluatedTerm&lt;PT&gt;&gt;, FnError&gt;
{
}</code></pre></div>
<p>Note, that both functions return a <code>Result</code> and therefore can gracefully fail.</p>
<p><code>DynamicFunctions</code> can be called with an array of any type implementing the EvaluatedTerm
trait. The result must also implement EvaluatedTerm. Rust offers a unique ID for each type.
Using this type we can check during runtime whether types are available. The types of each
variable, constant and function are preserved and stored alongside the <code>DynamicFunction</code>.</p>
<p>The following function is a simple example for a constant:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>puffin::algebra::error::FnError;

<span class="kw">pub fn </span>fn_some_value() -&gt; <span class="prelude-ty">Result</span>&lt;u32, FnError&gt; {
    <span class="prelude-val">Ok</span>(<span class="number">42</span>)
}</code></pre></div>
<p>It returns one possibility for the cipher suites which could be sent during a <code>ClientHello</code>.</p>
</div></details><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.dynamic_fn.html" title="macro puffin::algebra::dynamic_function::dynamic_fn">dynamic_<wbr>fn</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DynamicFunctionShape.html" title="struct puffin::algebra::dynamic_function::DynamicFunctionShape">Dynamic<wbr>Function<wbr>Shape</a></div><div class="desc docblock-short">Describes the shape of a <a href="trait.DynamicFunction.html" title="trait puffin::algebra::dynamic_function::DynamicFunction"><code>DynamicFunction</code></a></div></li><li><div class="item-name"><a class="struct" href="struct.TypeShape.html" title="struct puffin::algebra::dynamic_function::TypeShape">Type<wbr>Shape</a></div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.DescribableFunction.html" title="trait puffin::algebra::dynamic_function::DescribableFunction">Describable<wbr>Function</a></div><div class="desc docblock-short">This trait is implemented for function traits in order to:</div></li><li><div class="item-name"><a class="trait" href="trait.DynamicFunction.html" title="trait puffin::algebra::dynamic_function::DynamicFunction">Dynamic<wbr>Function</a></div><div class="desc docblock-short">Cloneable type for dynamic functions. This trait is automatically implemented for arbitrary
closures and functions of the form: <code>Fn(&amp;Vec&lt;Box&lt;dyn Any&gt;&gt;) -&gt; Box&lt;dyn Any&gt;</code></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.format_args.html" title="fn puffin::algebra::dynamic_function::format_args">format_<wbr>args</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="fn" href="fn.hash_type_id.html" title="fn puffin::algebra::dynamic_function::hash_type_id">hash_<wbr>type_<wbr>id</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Hashes <a href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId"><code>TypeId</code></a>s to be more readable</div></li><li><div class="item-name"><a class="fn" href="fn.make_dynamic.html" title="fn puffin::algebra::dynamic_function::make_dynamic">make_<wbr>dynamic</a></div></li></ul></section></div></main></body></html>