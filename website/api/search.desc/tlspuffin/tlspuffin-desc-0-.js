searchState.loadedDescShard("tlspuffin", 0, "TODO: Write intro: …\nThe <em>tls</em> module provides concrete implementations for the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDER encoded certificate. DER works, because: DER is a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStatic configuration for creating a new agent state for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTlsQueryMatcher contains TLS-related typing information, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCertificate for <code>ALICE_PRIVATE_KEY</code>\nPrivate key usually used for the server\nCertificate for <code>BOB_PRIVATE_KEY</code>\nPrivate key usually used for the client\nCertificate for <code>EVE_PRIVATE_KEY</code>\nPrivate key usually which identifies the attacker. This …\nCertificate for <code>RANDOM_EC_PRIVATE_KEY_PKCS8</code>\nRandom EC (prime256v1) key with no specific use. Encoded …\nA PUT which is backed by a TCP stream to a server. In …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSignature which contains all functions defined in the <code>tls</code> …\nFunction symbol which can be used for debugging\nThis modules contains all the concrete implementations of …\nExtracted from <code>rustls</code>.\nImplementation of  special traces. Each may represent a …\nExtensions according to IANA: …\nExtensions according to IANA: …\nUsed in heartbleed attack\nCertificateAuthorities =&gt; 0x002f,\nCookie =&gt; 0x002c,\nEarlyData =&gt; 0x002a,\nALProtocolNegotiation =&gt; 0x0010,\nExtendedMasterSecret =&gt; 0x0017,\nKeyShare =&gt; 0x0033,\nPreSharedKey =&gt; 0x0029,\nPSKKeyExchangeModes =&gt; 0x002d,\nRenegotiationInfo =&gt; 0xff01,\nServerName =&gt; 0x0000,\nSessionTicket =&gt; 0x0023,\nSignatureAlgorithmsCert =&gt; 0x0032,\nSignatureAlgorithms =&gt; 0x000d,\nSCT =&gt; 0x0012,\nStatusRequest =&gt; 0x0005,\nEllipticCurves =&gt; 0x000a,\nSupportedVersions =&gt; 0x002b,\nTransportParametersDraft =&gt; 0xffa5\nTransportParameters/quic_transport_parameters =&gt; 0x0039,\nCertificate =&gt; 0x0b,\nCertificateRequest =&gt; 0x0d,\nCertificateStatus =&gt; 0x16,\nCertificateVerify =&gt; 0x0f,\nClientHello =&gt; 0x01,\nClientKeyExchange =&gt; 0x10,\nEncryptedExtensions =&gt; 0x08,\nFinished =&gt; 0x14,\nHelloRequest/hello_request_RESERVED =&gt; 0x00,\nHelloRetryRequest =&gt; 0x06,\nSpecific ClientHello Random recognized by the client as …\nKeyUpdate =&gt; 0x18,\nMessageHash =&gt; 0xfe\nNewSessionTicket =&gt; 0x04,\nServerHello =&gt; 0x02,\nServerHelloDone =&gt; 0x0e,\nServerKeyExchange =&gt; 0x0c,\nDecrypt a whole flight of application messages and return …\nDecrypt a whole flight of handshake messages and return a …\nDecrypt an Application data message containing multiple …\nItems for use in a client.\nAPIs for implementing QUIC TLS\nItems for use in a server.\nMessage signing interfaces and implementations.\nA trust anchor, commonly known as a “Root Certificate.”\nA container for root certificates able to provide a …\nAdd a single DER-encoded certificate to the store.\nParse the given DER-encoded certificates and add all that …\nAdds all the given TrustAnchors <code>anchors</code>.  This does not …\nMake a new, empty <code>RootCertStore</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs an <code>OwnedTrustAnchor</code> from its components.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if there are no certificates.\nSay how many certificates are in the container.\nThe list of roots.\nReturn the Subject Names for certificates in the container.\nGet a <code>webpki::TrustAnchor</code> by borrowing the owned elements.\nA <code>MessageDecrypter</code> which doesn’t work.\nA <code>MessageEncrypter</code> which doesn’t work.\nA write or read IV.\nObjects with this trait can decrypt TLS messages.\nObjects with this trait can encrypt TLS messages.\nPerform the decryption over the concerned TLS message.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe server is identified by a DNS name.  The name is sent …\nThe provided input could not be parsed because it is not a …\nEncodes ways a client can know the expected name of the …\nReturn a prefix-free, unique encoding for the name.\nReturn the name that should go in the SNI extension. If …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nData specific to the peer’s side (client or server).\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWe received a fatal alert.  This means the peer is unhappy.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nThe peer sent us a syntactically incorrect TLS message.\nContext around a corrupt TLS message payload that resulted …\nThe peer sent us a TLS message with invalid contents.\nWe couldn’t decrypt a message.  This is invariably fatal.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nThis function doesn’t work until the TLS handshake is …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nWe received a certificate which includes invalid data.\nWe received an invalidly encoded certificate from the peer.\nWe received a certificate with invalid signature.\nWe received a certificate with invalid signature type.\nThe presented SCT(s) were invalid.\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nThe peer doesn’t support a protocol version/feature we …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nThe certificate verifier doesn’t support the given type …\nReturns the type of content we expected but found as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received\nThis deals with keeping a running hash of the handshake …\nEarly stage buffering of handshake payloads.\nWe decided not to do client auth after all, so discard the …\nHash/buffer a handshake message.\nHash/buffer a handshake message.\nThe digest algorithm\nbuffer for client-auth.\nNone before we know what hash function we’re using\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current hash value.\nGet the hash value if we were to hash <code>extra</code> too.\nGet the hash value if we were to hash <code>extra</code> too, using …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a Handshake hash which return the same override …\nTake the current hash value, and encapsulate it in a ‘…\nWe might be doing client auth, so need to keep a full log …\nWe now know what hash function the verify_data will use.\nTakes this object’s buffer containing all handshake …\nHash or buffer a byte slice.\nThis type contains a single certificate by value.\nThis type contains a private key by value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis trait represents the ability to do something useful …\nKeyLog that does exactly nothing.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLog the given <code>secret</code>.  <code>client_random</code> is provided for …\nIndicates whether the secret with label <code>label</code> will be …\nA list of all the key exchange groups supported by rustls.\nAn in-progress key exchange.  This has the algorithm, our …\nEphemeral ECDH on secp256r1 (aka NIST-P256)\nEphemeral ECDH on secp384r1 (aka NIST-P384)\nA key-exchange group supported by rustls.\nEphemeral ECDH on curve25519 (see RFC7748)\nThe corresponding ring agreement::Algorithm\nChoose a SupportedKxGroup by name, from a list of …\nCompletes the key exchange, given the peer’s public key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the group being used.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe IANA “TLS Supported Groups” name of the group\nStart a key exchange, using the given SupportedKxGroup.\nA HashMap-alike, which never gets larger than a specified …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new LimitedCache with the given rough capacity.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn externally length’d payload\nAn arbitrary, unknown-content, u16-length-prefixed payload\nAn arbitrary, unknown-content, u24-length-prefixed payload\nAn arbitrary, unknown-content, u8-length-prefixed payload\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains an invalid message as a header.\nThis deframer works to reconstruct TLS messages from …\nMight contain a valid message if we receive more. Perhaps …\nContains a valid frame as a prefix.\nA fixed-size buffer containing the currently-accumulating …\nSet to true if the peer is not talking TLS, but some other …\nCompleted frames for output.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if we have messages for the caller to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRead some bytes from <code>rd</code>, and add them to our internal …\nDoes our <code>buf</code> contain a full message?  It does if it is big …\nWhat size prefix of <code>buf</code> is used.\nThe <code>AlertDescription</code> TLS protocol enum.\nThe <code>AlertLevel</code> TLS protocol enum.\nThe <code>CertificateStatusType</code> TLS protocol enum.\nThe <code>CipherSuite</code> TLS protocol enum.\nThe <code>ClientCertificateType</code> TLS protocol enum.\nThe <code>Compression</code> TLS protocol enum.\nThe <code>ContentType</code> TLS protocol enum.\nThe <code>ECCurveType</code> TLS protocol enum.\nThe <code>ECPointFormat</code> TLS protocol enum.\nThe <code>ExtensionType</code> TLS protocol enum.\nThe <code>HandshakeType</code> TLS protocol enum.\nThe <code>HashAlgorithm</code> TLS protocol enum.\nThe <code>HeartbeatMessageType</code> TLS protocol enum.\nThe <code>HeartbeatMode</code> TLS protocol enum.\nThe <code>KeyUpdateRequest</code> TLS protocol enum.\nThe <code>NamedCurve</code> TLS protocol enum.\nThe <code>NamedGroup</code> TLS protocol enum.\nThe <code>PSKKeyExchangeMode</code> TLS protocol enum.\nThe <code>ProtocolVersion</code> TLS protocol enum.\nThe <code>ServerNameType</code> TLS protocol enum.\nThe <code>SignatureAlgorithm</code> TLS protocol enum.\nThe <code>SignatureScheme</code> TLS protocol enum.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the Message <code>msg</code> and re-fragment it into new messages …\nEnqueue borrowed fragments of (version, typ, payload) which\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMake a new fragmenter.\nOnly supports OCSP\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nRFC6066: “The ServerNameList MUST NOT contain more than …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a basic SNI ServerNameRequest quoting <code>hostname</code>.\nMake a new one with one entry.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis works to reconstruct TLS handshake messages from …\nTLS allows for handshake messages of up to 16MB.  We …\nBuffer contains a header that introduces a message that is …\nWe need more data to see a header and complete body.\nBuffer contains a full header and body.\nThe message payload we’re currently accumulating.\nDoes our <code>buf</code> contain a full handshake payload?  It does if …\nTake a TLS handshake payload off the front of <code>buf</code>, and put …\nCompleted handshake frames for output.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDo we have any buffered data?\nMake a new HandshakeJoiner.\nTake the message, and join/split it as needed. Return the …\nDo we want to process this message?\nA macro which defines an enum type.\nA TLS frame, named TLSPlaintext in the standard.\nContent type, version and size.\nThis is the maximum on-the-wire size of a TLSCiphertext. …\nMaximum on-wire message size.\nA message with decoded payload\nA TLS frame, named TLSPlaintext in the standard.\nA decrypted TLS frame\nExtracts knowledge from a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForce conversion into a plaintext message.\nExtract multiple messages payloads from one …\n<code>MessageError</code> allows callers to distinguish between valid …\nTo <code>read</code> an <code>EvaluatedTerm&lt;PT&gt;</code> out of a bitstring, we cannot …\nKeys used to communicate in a single direction\nKeys for the handshake space\nA QUIC header protection key\nKey material for use in QUIC packet spaces\nComplete set of keys used to communicate with the peer\nKeys for 1-RTT data\nKeys to encrypt or decrypt the payload of a packet\nPacket protection keys for bidirectional 1-RTT …\nGeneric methods for QUIC sessions\nSecrets used to encrypt/decrypt traffic\nAEAD tag, must be appended to encrypted cipher text\nFirst stable RFC\nDraft versions 29, 30, 31 and 32\nQUIC protocol version\nEmit the TLS description code of a fatal alert, if one has …\nSecret used to encrypt packets transmitted by the client\nNumber of times the packet key can be used without …\nRemoves QUIC Header Protection.\nDecrypt a QUIC packet\nAdds QUIC Header Protection.\nEncrypt a QUIC packet\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEncrypts or decrypts a packet’s headers\nConstruct keys for use with initial packets\nNumber of times the packet key can be used without …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes unique nonces for each packet\nEncrypts or decrypts a packet’s payload\nEncrypts outgoing packets\nEncrypts outgoing packets\nDerive the next set of packet keys\nCompute the nonce to use for encrypting or decrypting …\nEncrypts or decrypts the payload of a packet\nReturn the TLS-encoded transport parameters for the session…\nConsume unencrypted TLS handshake data.\nDecrypts incoming packets\nDecrypts incoming packets\nExpected sample length for the key’s algorithm\nSecret used to encrypt packets transmitted by the server\nThe cipher suite used for this packet key\nCipher suite used with these secrets\nTag length for the underlying AEAD algorithm\nEmit unencrypted TLS handshake data.\nCompute the keys for encrypting/decrypting 0-RTT packets, …\nHeader and packet keys for the handshake space\nHeader and packet keys for 1-RTT data\nSecrets to derive updated keys from\nFill the whole slice with random material.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn a uniformly random u32.\nMake a <code>Vec&lt;u8&gt;</code> of the given size containing random …\nKeying material in use.\nNo keying material.\nKeying material present, but not yet in use.\nDecrypt a TLS message.\nReturn true if we outright refuse to do anything with the …\nEncrypt a TLS message.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrepare to use the given <code>MessageDecrypter</code> for future …\nPrepare to use the given <code>MessageEncrypter</code> for future …\nSet and start using the given <code>MessageDecrypter</code> for future …\nSet and start using the given <code>MessageDecrypter</code> for future …\nSet and start using the given <code>MessageEncrypter</code> for future …\nStart using the <code>MessageDecrypter</code> previously provided to …\nStart using the <code>MessageEncrypter</code> previously provided to …\nReturn true if the peer appears to getting close to …\nReturn true if we are getting close to encrypting too many …\nA trait for the ability to encrypt and decrypt tickets.\nDecrypt <code>cipher</code>, validating its authenticity protection and …\nReturns true if this implementation will encrypt/decrypt …\nEncrypt and authenticate <code>plain</code>, returning the resulting …\nReturns the lifetime in seconds of tickets produced now. …\nA packaged-together certificate chain, matching <code>SigningKey</code> …\nA SigningKey that uses exactly one TLS-level …\nA SigningKey that uses exactly one TLS-level …\nErrors while signing\nA thing that can sign a message.\nAn abstract signing key.\nWhat kind of key we have.\nParse <code>der</code> as any ECDSA key type, returning the first which …\nParse <code>der</code> as any EdDSA key type, returning the first which …\nParse <code>der</code> as any supported key encoding/type, returning …\nThe certificate chain.\nChoose a <code>SignatureScheme</code> from those offered.\nConvert a SEC1 encoding to PKCS8, and ask ring to parse …\nCheck the certificate chain for validity:\nThe end-entity certificate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe certified key.\nMake a new <code>ECDSASigningKey</code> from a DER encoding in PKCS#8 …\nMake a new <code>Ed25519SigningKey</code> from a DER encoding in PKCS#8 …\nMake a new CertifiedKey, with the given chain and key.\nAn optional OCSP response from the certificate issuer, …\nReveals which scheme will be used when you call <code>sign()</code>.\nAn optional collection of SCTs from CT logs, proving the …\nSigns <code>message</code> using the selected scheme.\nThe set of schemes we support for signatures and that are …\nA list of all the cipher suites supported by rustls.\nAES with 128-bit keys in Galois counter mode.\nAES with 256-bit keys in Galois counter mode.\nBulk symmetric encryption scheme used by a cipher suite.\nChacha20 for confidentiality with poly1305 for …\nCommon state for cipher suites (both for TLS 1.2 and TLS …\nThe cipher suite configuration that an application should …\nA cipher suite supported by rustls.\nA TLS 1.2 cipher suite\nA TLS 1.3 cipher suite\nHow to do bulk encryption.\nReturn true if <code>sigscheme</code> is usable by any of the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhich hash function to use with this suite.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn a list of the ciphersuites in <code>all</code> with the suites …\nReturn a list of the ciphersuites in <code>all</code> with the suites …\nThe cipher suite’s identifier\nThe TLS enumeration naming this cipher suite.\nReturn true if this suite is usable for a key only …\nReturn supported protocol version for the cipher suite.\nThis is a <code>ProducesTickets</code> implementation which uses any …\nA ticketer that has a ‘current’ sub-ticketer and a …\nA concrete, safe ticket creation mechanism.\nThe timebase for expiring and rolling tickets and ticketing\nDecrypt <code>ciphertext</code> and recover the original message.\nEncrypt <code>message</code> and return the ciphertext.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf it’s time, demote the <code>current</code> ticketer to <code>previous</code> …\nMake a ticketer with recommended configuration and a …\n<code>lifetime</code> is in seconds, and is how long the current …\nMake the recommended Ticketer.  This produces tickets with …\nTLS1.2 per-connection keying material\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nA TLS 1.2 cipher suite supported by rustls.\nCommon cipher suite fields.\nThis is a non-standard extension which extends the key …\nHow long the fixed part of the ‘IV’ is.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhich hash function to use with this suite.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHow to exchange/agree keys.\nMake a <code>MessageCipherPair</code> based on the given supported …\nResolve the set of supported <code>SignatureScheme</code>s from the …\nHow to sign messages for authentication.\nThe RFC7905/RFC7539 ChaCha20Poly1305 construction. This …\nThe RFC7905/RFC7539 ChaCha20Poly1305 construction. This …\nA <code>MessageDecrypter</code> for AES-GCM AEAD ciphersuites.  TLS1.2 …\nA <code>MessageEncrypter</code> for AES-GCM AEAD ciphersuites. TLS 1.2 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe TLS1.3 ciphersuite TLS_AES_128_GCM_SHA256\nThe TLS1.3 ciphersuite TLS_AES_256_GCM_SHA384\nThe TLS1.3 ciphersuite TLS_CHACHA20_POLY1305_SHA256\nA TLS 1.3 cipher suite supported by rustls.\nCan a session using suite self resume from suite prev?\nCommon cipher suite fields.\nDerive a <code>MessageDecrypter</code> object from the concerned TLS 1.3\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhich hash function to use with this suite.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the TLS1.3 key schedule.  It stores the current …\nKeySchedule for early data stage.\nKeySchedule during handshake.\nPre-handshake key schedule\nKeySchedule during traffic stage.  All traffic &amp; exporter …\nKeySchedule during traffic stage.\nThe kinds of secret we can extract from <code>KeySchedule</code>.\nDerive a secret of given <code>kind</code>, using current handshake …\nDerive a secret of given <code>kind</code> using the hash of the empty …\nDerive the next application traffic secret, returning it.\nDerive the PSK to use given a resumption_master_secret and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInput the empty secret.\nInput the given secret.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSign the finished message consisting of <code>hs_hash</code> using a …\nSign the finished message consisting of <code>hs_hash</code> using the …\nThis is a byte buffer that is built from a vector of byte …\nTake and append the given <code>bytes</code>.\nAppend a copy of <code>bytes</code>, perhaps a prefix if we’re near …\nFor a proposed append of <code>len</code> bytes, how many bytes should …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf we’re empty\nHow many bytes we’re storing\nTake one of the chunks from this object.  This function …\nRead data out of this object, writing it into <code>buf</code> and …\nSets the upper limit on how many bytes this object can …\nRead data out of this object, passing it <code>wr</code>\nA <code>ClientCertVerifier</code> that will allow both anonymous and …\nA <code>ClientCertVerifier</code> that will ensure that every client …\nPolicy for enforcing Certificate Transparency.\nZero-sized marker type representing verification of a …\nSomething that can verify a client certificate chain\nA type which encapsuates a string that is a syntactically …\nZero-sized marker type representing verification of a …\nTurns off client authentication.\nWhich signature verification mechanisms we support.  No …\nZero-sized marker type representing verification of a …\nSomething that can verify a server certificate chain, and …\nDefault <code>ServerCertVerifier</code>, see the trait impl for more …\nMake a <code>HandshakeSignatureValid</code>\nMake a <code>ServerCertVerified</code>\nMake a <code>ClientCertVerified</code>\nReturn <code>Some(true)</code> to require a client certificate and …\nReturns the subject names of the client authentication …\nConstructs the signature message specified in section …\nConstructs the signature message specified in section …\nConstructs the signature message specified in section …\nConstructs the signature message specified in section …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a new <code>WebPkiVerifier</code>.\nCreate a new policy.\nConstruct a new <code>AllowAnyAuthenticatedClient</code>.\nConstruct a new <code>AllowAnyAnonymousOrAuthenticatedClient</code>.\nConstructs a <code>NoClientAuth</code> and wraps it in an <code>Arc</code>.\nReturns <code>true</code> to enable the server to request a client …\nReturns <code>true</code> if Rustls should ask the server to send SCTs.\nReturn the list of SignatureSchemes that this verifier …\nReturn the list of SignatureSchemes that this verifier …\nReturns the signature verification methods supported by …\nVerify the end-entity certificate <code>end_entity</code> is valid for …\nVerify the end-entity certificate <code>end_entity</code> is valid for …\nWill verify the certificate is valid in the following ways:\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nA list of all the protocol versions supported by rustls.\nThe version configuration that an application should use …\nA TLS protocl version supported by rustls.\nTLS1.2\nTLS1.3\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe TLS enumeration naming this version.\nPrepend stuff to <code>bytes</code> to put it in a DER SEQUENCE.\nSeed which contains the whole transcript in the tree. This …\nSeed which contains the whole transcript in the tree. This …\nSeed which triggers a MITM attack. It changes the cipher …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nhttps://nvd.nist.gov/vuln/detail/cve-2021-3449\n…\n…\nA simplified version of <code>seed_cve_2022_25640</code>")