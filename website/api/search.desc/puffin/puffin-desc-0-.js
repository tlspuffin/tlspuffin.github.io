searchState.loadedDescShard("puffin", 0, "<code>Agent</code>s represent communication participants like Alice, …\nThe <em>term</em> module defines typed<code>Term</code>s of the form …\nThe fuzzer module setups the fuzzing loop. It also is …\nThis module adds plotting capabilities to<code>Term</code>sand Traces. …\nThe communication streams between <code>Agent</code>s.\nThis module define the execution <code>Trace</code>s.\nDefinition of the VariableData trait. A VariableData can …\nAn <code>Agent</code> holds a non-cloneable reference to a Stream.\n<code>AgentDescriptor</code>s act like a blueprint to spawn <code>Agent</code>s with …\nCopyable reference to an <code>Agent</code>. It identifies exactly one …\nIf agent is a server: Make client auth. a requirement. If …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the agent is reusable with the descriptor.\nChecks whether the agent is in a good state.\nIf agent is a server: No effect, servers always send …\nShut down the agent by consuming it and returning a string …\nWhether we want to try to reuse a previous agent. This is …\nWhether the agent which holds this descriptor is a server.\nDetermines whether two instances match. We can also ask it …\nThis module provides an enum for terms. A term can either …\nThis module provides traits for calling rust functions …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis module provides a DLS for writing <code>Term</code>s within Rust. …\nThis module provides<code>Term</code>s as well as iterators over them.\nA function symbol with fixed arity and fixed types.\nA variable symbol with fixed type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe struct which holds information about how to query this …\nID of this variable. This id stays the same during cloning.\nID of this function. This id stays the same during cloning.\nUnique ID of this variable. Uniqueness is guaranteed …\nUnique ID of this function. Uniqueness is guaranteed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis trait is implemented for function traits in order to:\nCloneable type for dynamic functions. This trait is …\nDescribes the shape of a <code>DynamicFunction</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nHashes <code>TypeId</code>s to be more readable\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nError which happened because a cryptographic operation …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRecords a universe of functions. Signatures are containers …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstruct a <code>Signature</code> from the given <code>FunctionDefinition</code>s.\nCreate a new <code>Function</code> distinct from all existing <code>Function</code>s.\nAn <code>Function</code> applied to zero or more <code>Term</code>s (e.g. (<code>f(x, y)</code>, …\nA first-order term: either a <code>Variable</code> or an application of …\nA concrete but unspecified <code>Term</code> (e.g. <code>x</code>, <code>y</code>). See <code>Variable</code> …\nIf <code>tree_mode</code> is true then each subgraph is self-contained …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>tlspuffin::term::op_impl::op_protocol_version</code> -&gt; …\nfinds the last claim matching <code>type</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThings we can encode and read from a Reader.\nRead from a byte slice.\nEncode yourself by appending onto <code>bytes</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvenience function to get the results of <code>encode()</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecode yourself by fiddling with the <code>Reader</code>. Return Some …\nRead one of these from the front of <code>bytes</code> and return it.\nSome error which was caused because of agents or their …\nReturned if a concrete function from the protocol fails or …\nThere was an unexpected IO error. Should never happen …\nPUT reported an error\nError while operating on a <code>Stream</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStarts the fuzzing loop\nStats to display both cumulative and per-client stats\nGenerates a zoo of terms form a <code>Signature</code>. For each …\nFirst [<code>Feedback</code>]\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHow many iterations each stage gets, as an upper bound It …\nSecond [<code>Feedback</code>]\nStarts the fuzzing loop\nBelow this term size we no longer mutate. Note that it is …\nGENERATE: Generates a previously-unseen term using a term …\nREMOVE AND LIFT: Removes a sub-term from a term and …\nREPEAT: Repeats an input which is already part of the trace\nREPLACE-MATCH: Replaces a function symbol with a different …\nREPLACE-REUSE: Replaces a sub-term with a different …\nSKIP:  Removes an input step\nSWAP: Swaps a sub-term with a different sub-term which is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\nHelpers for asan\nSetups the environment variable for ASAN, because …\nThe default mutational stage\nA <code>Mutator</code> that schedules one of the embedded mutations on …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCompute the number of iterations used to apply stacked …\nGets the number of iterations as a random number\nGet the mutations\nThe mutator, added to this stage\nThe list of mutators, added to this stage (as mutable ref)\nCreate a new <code>PuffinScheduledMutator</code> instance specifying …\nCreates a new default mutational stage\nGet the next mutation to apply\nTracking stats during fuzzing and display both per-client …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSome log file unique id\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nProvide a way to extract knowledge out of a …\nA non-structured version of <code>ProtocolMessage</code>. This can be …\nStore a flight of opaque messages, a vec of all the …\nDefines the protocol which is being tested.\nA structured message. This type defines how all possible …\nDeframes a stream of bytes into distinct …\nStore a message flight, a vec of all the messages sent by …\nDefines the types used to manipulate and concretize Terms\nCreates a sane initial seed corpus.\nFill <code>knowledges</code> with new knowledge gathered form the type …\nGet the signature that is used in the protocol\nGeneric trait used to define the interface with a concrete …\nReturns a textual representation of the state in which …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether the Put is in a good state\nProcess incoming buffer, internal progress, can fill in …\nIn-place reset of the state\nShut down the PUT by consuming it and returning a string …\nReturns a textual representation of the version of the PUT …\nFactory for instantiating programs-under-test.\nRegistry for Factories. An instance of this is usually …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDescribes in- or outbound channels of an …\nA MemoryStream has two <code>Channel</code>s. The Stream also …\nExecutes the given command directly.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nQueues the given command for further execution.\nPerforms a set of actions within a synchronous update.\nTakes a single TLS message from the outbound channel\nThere are two action types <code>OutputAction</code> and <code>InputAction</code>.\nProvide inputs to the <code>Agent</code>.\nKnowledge describes an atomic piece of knowledge inferred …\nAdvance the <code>Agent</code>’s state and process the produced …\nRawKnowledge stores\nSource stores the origin of a knowledge, whether the agent …\nThe <code>TraceContext</code> represents the state of an execution.\nReturns the variable which matches best -&gt; highest …\nReturns the variable which matches best -&gt; highest …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe knowledge of the attacker\nCount the number of sub-messages of type <code>type_id</code> in the …\nCount the number of sub-messages of type <code>type_id</code> in the …\nCount the number of sub-messages of type <code>type_id</code> with the …")